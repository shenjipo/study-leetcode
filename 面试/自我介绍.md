自我介绍

> 面试官您好，我叫王星，本科就读于江苏理工学院，专业是物联网工程，目前在读杭州电子科技大学硕士，专业是计算机技术，预计明年6月毕业。在研究生期间有过两段实习经历，
>
> 首先是去年1月份到6月份在浙江同博科技公司参与的舟山市智慧海渔综合管理服务平台开发，这是我们实验室与同博公司合作的项目，这个项目的目标是服务于舟山市海洋渔业局，帮助渔业局实时监管全市的渔业资源。z这个渔业资源管理平台前端开发的技术栈主要包括Vue，Vuex，Vue-router，leaflet还有git。在这个项目中我主要负责两个方面的功能开发，一个是使用地图交互框架leaflet在海图上渲染显示船舶，另一个是使用echarts图表做一个大屏页面统计显示一些常用的渔业资源数据。
>
> 第二段实习经历是我在华为云会议windows项目组的实习，这个实习目前还有一周结束。华为云会议windows端主要是面向企业用户提供视频会议的服务。使用的技术栈主要是Electron、react，redux和git。其中Elcetron是一个跨平台的桌面应用程序开发框架，包括windows，macos和linux。这个项目中用Electron开发windows端的程序，在实习期间我负责两个功能的开发，一个是手机号输入框公共组件的抽取，另一个是使用插件化的方式开发反馈功能。
>
> 谢谢

舟山项目两个点

> 1.使用leaflet框架把渔船渲染在海图上是这个项目的一个难点，实现这个的思路是自己写一个渔船对象，去继承leaflet提供的一个多边形对象，通过调用父类的addTo方法就可以在海图上显示船舶。但是leaflet为了考虑兼容性，没有采用ES6的特性，而是自己通过js的原型链和构造函数自己实现了一套类似与ES6的extend的继承，它的思路大概是这样，首先写一个Class对象，然后实现一个继承的函数挂载在Class对象上，类似于ES6中的类静态方法，leaflet中提供的所有对象都继承自这个Class。这个继承函数的思路大概是这样，该函数接收一个props对象，该对象表示子类具有的一些方法和属性，返回一个function对象newClass，newClass的原型对象的原型链指向了this的prototype对象，用于继承父类的方法，然后把props对象的的所有属性和方法全部复制到新的newClass对象上，newClass的内部判断是否有initilize方法，如果有，会通过call
>
> 最后，再把直接挂载再父类对象上的方法和属性复制到newClass对象上，这一步是把父类的静态方法复制到子类上
>
> 从ES6的继承来看，子类要继承父类的三类对象，第一个是父类的自身的属性，第二类是挂载再父类原型对象上的方法，第三类是父类的静态方法，父类的静态方法直接挂载再父类对象上。
>
> 对于父类的自身属性的继承，采用的是再子类函数内部通过call方法调用父类构造函数，
>
> 对于父类原型对象上的方法继承，采用的是让子类的原型对象的__proto__对象指向父类的原型对象
>
> 对于直接挂载再父类对象上的方法，遍历父类对象的属性，把父类的非prototype对象直接复制给子类
>
> 2.Echarts图表的封装
>
> 本项目使用的Echarts版本是4.X，
>
> **大屏自适应设计思路**
>
> > 初始设计大屏的宽高比例为1920:1080
> >
> > ```javascript
> > {
> > width: 1920px;
> > height: 1080px;
> > position: absolute;
> > top: 50%;
> > left: 50%;
> > transform: translate(-50%, -50%);
> > }
> > ```
> >
> > 使用绝对定位结合transform属性来动态调整最外层的div元素宽高，设置绝对定位后，该div元素会脱离文档流，然后根据其第一个设置了positon的父元素位置去定位自己的位置，本项目中就是整个网页的左上角，然后设置向右向下平移50%（父元素宽度或者高度的50%）的位置，接着通过transform使得该元素向左向上平移自身宽度和高度的一半
> >
> > 然后注册一个函数，监听浏览器窗口发生的变化，根据获取到的用户当前的窗口宽高`window.innerWidth` `window.innerHeight`计算宽高比例，根据比例进行缩放
> >
> > ```javascript
> > //1.按照固定比例缩放
> > if (currentRate > baseProportion) {
> >   // 表示更宽
> >   scale.width = ((window.innerHeight * baseProportion) / baseWidth).toFixed(5)
> >   scale.height = (window.innerHeight / baseHeight).toFixed(5)
> >   appRef.style.transform = `scale(${scale.width}, ${scale.height}) translate(-50%, -50%)`
> > } else {
> >   // 表示更高
> >   scale.height = ((window.innerWidth / baseProportion) / baseHeight).toFixed(5)
> >   scale.width = (window.innerWidth / baseWidth).toFixed(5)
> >   appRef.style.transform = `scale(${scale.width}, ${scale.height}) translate(-50%, -50%)`
> > }
> > //2.填充屏幕
> > const ratio_x = window.innerWidth / baseWidth
> > const ratio_y = window.innerHeight / baseHeight
> > appRef.style.transform = `scale(${ratio_x}, ${ratio_y}) translate(-50%, -50%)`
> > ```
> >
> > 接着使用resize注册监听函数，如果浏览器窗口大小发生变化就重新调整大小
> >
> > ```javascript
> > window.addEventListener('resize', this.resize)
> > ```
> >
> > 最后通过Vue混入的方法引入
> >
> > ```javascript
> > mixins: [ drawMixin ],
> > ```
>
> **Echarts封装思路**
>
> > 第一层封装 ，这一层仅仅封装了一个vue组件，该组件模板中仅仅有一个dom元素，它根据接收到的参数来生成图表
> >
> > 首先写一个初始的echarts组件，该组件仅仅有为echaets图表准备的div dom，使用echaets的init初始化方法生成一个echaets实例并且通过setOption方法填充数据，生成图表，图表的相关配置对象通过props来从父组件接收，例如id，图表标题，高度宽度等。使用watch来监听图表的数据变化，刷新图标数据
> >
> > 第二层封装，这一层通过传递一些基本参数（样式），生成基本的柱状图，折线图，饼图
> >
> > 首先引入第一层封装的ecahrts组件，设置宽高参数，还有options中的一部分参数（用来确定图表类型，坐标轴样式等），图表的标题，id，数据仍然使用props来从父组件接收。同样使用watch监听options参数来更新图表数据，图表的一些交互事件使用emit方法把事件发送给父组件
> >
> > 第三层 应用
> >
> > 引入第二层封装的组件，传递需要的参数，就可以生成对应的图表。



华为云会议项目两个点

> 